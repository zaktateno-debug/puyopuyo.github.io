<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>NEON PUYO PUYO</title>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --grid-color: #16213e;
            --puyo-red: #ff4d4d;
            --puyo-blue: #00d2ff;
            --puyo-green: #4cd137;
            --puyo-yellow: #fbc531;
        }
        body {
            background-color: var(--bg-color);
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        h1 { text-shadow: 0 0 10px #fff; margin-bottom: 10px; }
        #game-container {
            position: relative;
            border: 4px solid #fff;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(255,255,255,0.2);
            background: var(--grid-color);
            padding: 5px;
        }
        canvas { display: block; }
        .ui {
            position: absolute;
            top: 0;
            right: -120px;
            text-align: left;
            width: 100px;
        }
        .score-board { font-size: 20px; margin-bottom: 20px; }
        .controls { font-size: 14px; color: #ccc; }
    </style>
</head>
<body>

    <h1>NEON PUYO</h1>
    <div id="game-container">
        <canvas id="puyoCanvas"></canvas>
        <div class="ui">
            <div class="score-board">SCORE<br><span id="score">0</span></div>
            <div class="controls">
                [W] Rotate<br>
                [A] Left<br>
                [S] Down<br>
                [D] Right
            </div>
        </div>
    </div>

<script>
const COLS = 6;
const ROWS = 12;
const BLOCK_SIZE = 40;
const COLORS = [null, 'var(--puyo-red)', 'var(--puyo-blue)', 'var(--puyo-green)', 'var(--puyo-yellow)'];

const canvas = document.getElementById('puyoCanvas');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');

canvas.width = COLS * BLOCK_SIZE;
canvas.height = ROWS * BLOCK_SIZE;

let grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
let score = 0;
let activePuyo = null;
let dropCounter = 0;
let dropInterval = 1000;
let lastTime = 0;

class PuyoPair {
    constructor() {
        this.x = 2;
        this.y = 0;
        this.color1 = Math.floor(Math.random() * 4) + 1;
        this.color2 = Math.floor(Math.random() * 4) + 1;
        this.rot = 0; // 0: up, 1: right, 2: down, 3: left
    }

    getPositions() {
        const pos = [{ x: this.x, y: this.y }];
        if (this.rot === 0) pos.push({ x: this.x, y: this.y - 1 });
        else if (this.rot === 1) pos.push({ x: this.x + 1, y: this.y });
        else if (this.rot === 2) pos.push({ x: this.x, y: this.y + 1 });
        else if (this.rot === 3) pos.push({ x: this.x - 1, y: this.y });
        return pos;
    }
}

function drawPuyo(x, y, colorIndex) {
    if (!colorIndex) return;
    const cx = x * BLOCK_SIZE + BLOCK_SIZE / 2;
    const cy = y * BLOCK_SIZE + BLOCK_SIZE / 2;
    const radius = BLOCK_SIZE / 2 - 4;

    ctx.beginPath();
    ctx.arc(cx, cy, radius, 0, Math.PI * 2);
    ctx.fillStyle = COLORS[colorIndex];
    ctx.fill();
    
    // デザインのこだわり：光沢と瞳
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.beginPath();
    ctx.arc(cx - 6, cy - 6, 5, 0, Math.PI * 2);
    ctx.fill();
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // グリッド線の描画
    ctx.strokeStyle = '#222';
    for(let i=0; i<=COLS; i++) {
        ctx.moveTo(i*BLOCK_SIZE, 0); ctx.lineTo(i*BLOCK_SIZE, canvas.height);
    }
    for(let j=0; j<=ROWS; j++) {
        ctx.moveTo(0, j*BLOCK_SIZE); ctx.lineTo(canvas.width, j*BLOCK_SIZE);
    }
    ctx.stroke();

    // 固定済みぷよの描画
    grid.forEach((row, y) => row.forEach((val, x) => drawPuyo(x, y, val)));

    // 操作中ぷよの描画
    if (activePuyo) {
        const pos = activePuyo.getPositions();
        drawPuyo(pos[0].x, pos[0].y, activePuyo.color1);
        drawPuyo(pos[1].x, pos[1].y, activePuyo.color2);
    }
}

function moveLeft() { activePuyo.x--; if (collide()) activePuyo.x++; }
function moveRight() { activePuyo.x++; if (collide()) activePuyo.x--; }
function rotate() {
    const oldRot = activePuyo.rot;
    activePuyo.rot = (activePuyo.rot + 1) % 4;
    if (collide()) activePuyo.rot = oldRot;
}

function collide() {
    return activePuyo.getPositions().some(p => 
        p.x < 0 || p.x >= COLS || p.y >= ROWS || (p.y >= 0 && grid[p.y][p.x])
    );
}

async function drop() {
    activePuyo.y++;
    if (collide()) {
        activePuyo.y--;
        const pos = activePuyo.getPositions();
        pos.forEach((p, i) => {
            if (p.y >= 0) grid[p.y][p.x] = (i === 0) ? activePuyo.color1 : activePuyo.color2;
        });
        activePuyo = null;
        await resolveChain();
        activePuyo = new PuyoPair();
        if (collide()) {
            alert("GAME OVER! Score: " + score);
            grid = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
            score = 0;
            scoreEl.innerText = score;
        }
    }
}

async function resolveChain() {
    let changed = true;
    while (changed) {
        applyGravity();
        draw();
        let matches = findMatches();
        if (matches.length > 0) {
            matches.forEach(p => { grid[p.y][p.x] = 0; });
            score += matches.length * 10;
            scoreEl.innerText = score;
            await new Promise(r => setTimeout(r, 300));
        } else {
            changed = false;
        }
    }
}

function applyGravity() {
    for (let x = 0; x < COLS; x++) {
        let emptyRow = ROWS - 1;
        for (let y = ROWS - 1; y >= 0; y--) {
            if (grid[y][x] !== 0) {
                let temp = grid[y][x];
                grid[y][x] = 0;
                grid[emptyRow][x] = temp;
                emptyRow--;
            }
        }
    }
}

function findMatches() {
    let matched = [];
    let visited = Array.from({ length: ROWS }, () => Array(COLS).fill(false));

    for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
            if (grid[y][x] && !visited[y][x]) {
                let group = [];
                let color = grid[y][x];
                let stack = [{x, y}];
                while (stack.length) {
                    let p = stack.pop();
                    if (p.x<0 || p.x>=COLS || p.y<0 || p.y>=ROWS || visited[p.y][p.x] || grid[p.y][p.x] !== color) continue;
                    visited[p.y][p.x] = true;
                    group.push(p);
                    stack.push({x:p.x+1, y:p.y}, {x:p.x-1, y:p.y}, {x:p.x, y:p.y+1}, {x:p.x, y:p.y-1});
                }
                if (group.length >= 4) matched.push(...group);
            }
        }
    }
    return matched;
}

window.addEventListener('keydown', e => {
    if (!activePuyo) return;
    if (e.key === 'a' || e.key === 'A') moveLeft();
    if (e.key === 'd' || e.key === 'D') moveRight();
    if (e.key === 's' || e.key === 'S') drop();
    if (e.key === 'w' || e.key === 'W') rotate();
    draw();
});

function update(time = 0) {
    const deltaTime = time - lastTime;
    lastTime = time;
    dropCounter += deltaTime;
    if (dropCounter > dropInterval) {
        if (activePuyo) drop();
        dropCounter = 0;
    }
    draw();
    requestAnimationFrame(update);
}

activePuyo = new PuyoPair();
update();
</script>
</body>
</html>
